/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NanoBots
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// nano-bots/dispatcher.js
var import_obsidian5 = require("obsidian");

// nano-bots/nano_bot.js
var import_obsidian = require("obsidian");

// nano-bots/state.js
var NanoBotState = class {
  constructor() {
    this.state = { status: "waiting" };
    this._instance = null;
  }
  setStatusBar(element) {
    this.statusBar = element;
  }
  static thread(length = 16) {
    const array = new Uint8Array(length);
    window.crypto.getRandomValues(array);
    return Array.from(array, (byte) => byte.toString(16).padStart(2, "0")).join("");
  }
  static instance() {
    if (!this._instance) {
      this._instance = new NanoBotState();
    }
    return this._instance;
  }
  stop() {
    this.state.status = "stopped";
    this.state.thread = null;
    this.statusBar.toggleClass("status-hidden", true);
  }
  update(cartridge, new_state = null) {
    if (new_state) {
      this.state = new_state;
    }
    if (this.state.status !== "pending") {
      this.statusBar.toggleClass("status-hidden", true);
      return;
    }
    let text = "";
    if (!cartridge.meta.symbol) {
      text += "\u{1F916}";
    } else {
      text += cartridge.meta.symbol;
    }
    text += " " + cartridge.meta.name + "... ";
    let seconds = Math.floor((Date.now() - this.state.started_at) / 1e3);
    text += `(${seconds}s)`;
    this.statusBar.setText(text);
    this.statusBar.toggleClass("status-hidden", false);
    if (this.state.status === "pending") {
      setTimeout(() => this.update(cartridge), 500);
    }
  }
};
var state_default = NanoBotState;

// nano-bots/nano_bot.js
var NanoBot = class {
  static stop() {
    state_default.instance().stop();
  }
  static async perform(config, params, callback) {
    const cartridge = await this.cartridge(config, params.cartridge);
    this.stop();
    if (config.NANO_BOTS_STREAM) {
      this.stream_request(config, params, cartridge, callback);
    } else {
      this.non_stream_request(config, params, cartridge, callback);
    }
  }
  static async cartridges(config) {
    return await this.send_request(config, null, "GET", "/cartridges", 1e3);
  }
  static async cartridge(config, cartridge_id) {
    return await this.send_request(
      config,
      { id: cartridge_id },
      "POST",
      "/cartridges/source",
      1e3
    );
  }
  static non_stream_request(config, params, cartridge, callback) {
    const thread = state_default.thread();
    state_default.instance().update(cartridge, {
      status: "pending",
      started_at: Date.now(),
      thread
    });
    this.send_request(config, params, "POST", "/cartridges").then((response) => {
      if (state_default.instance().state.status !== "stopped" && state_default.instance().state.thread === thread) {
        state_default.instance().update(cartridge, { status: "finished" });
        callback(response);
      }
    });
  }
  static stream_request(config, params, cartridge, callback) {
    const thread = state_default.thread();
    state_default.instance().update(cartridge, {
      status: "pending",
      started_at: Date.now(),
      thread
    });
    this.send_request(config, params, "POST", "/cartridges/stream").then((response) => {
      let stream_id = response.id;
      if (!stream_id) {
        vscode.window.showErrorMessage("Nano Bots: No Stream ID received.");
        return;
      }
      let state = "";
      const streamChecker = () => {
        if (state_default.instance().state.status === "stopped" || state_default.instance().state.thread !== thread) {
          return;
        }
        this.send_request(config, null, "GET", "/cartridges/stream/" + stream_id).then(
          (response2) => {
            let output = response2.output;
            if (state !== output) {
              response2.fragment = output.slice(state.length);
              state = output;
              callback(response2);
            }
            if (response2.state === "finished") {
              state_default.instance().update(cartridge, { status: "finished" });
            } else {
              setTimeout(streamChecker, 0);
            }
          }
        );
      };
      setTimeout(streamChecker, 0);
    });
  }
  static async send_request(config, params, method, path, timeout = void 0, retries = 0) {
    const api_url = new URL(config.NANO_BOTS_API_ADDRESS + path);
    const headers = {
      "Content-Type": "application/json",
      NANO_BOTS_END_USER: "obsidian-" + config.NANO_BOTS_END_USER
    };
    if (config.NANO_BOTS_CARTRIDGES_PATH) {
      headers["NANO_BOTS_CARTRIDGES_PATH"] = config.NANO_BOTS_CARTRIDGES_PATH;
    }
    const requestOptions = {
      method,
      headers: new Headers(headers),
      body: params ? JSON.stringify(params) : null
    };
    try {
      const response = await this.fetchWithTimeout(api_url, requestOptions, timeout);
      const data = await response.json();
      if (!response.ok) {
        if (data && data.error && data.error.message) {
          throw new Error(data.error.message);
        } else {
          throw new Error(`Request returned status ${response.status}.`);
        }
      }
      return data;
    } catch (error) {
      if (retries < 2) {
        new import_obsidian.Notice(`Nano Bots: ${error.message} (${retries + 1}), retrying...`);
        return await this.send_request(config, params, method, path, timeout, retries + 1);
      } else {
        new import_obsidian.Notice(`Nano Bots: ${error.message} (3), cancelled.`);
        throw error;
      }
    }
  }
  static fetchWithTimeout(url, options, timeout) {
    return new Promise((resolve, reject) => {
      const timer = timeout ? setTimeout(() => {
        reject(new Error("Request timed out"));
      }, timeout) : null;
      fetch(url, options).then((response) => {
        if (timer)
          clearTimeout(timer);
        resolve(response);
      }).catch((error) => {
        if (timer)
          clearTimeout(timer);
        reject(error);
      });
    });
  }
};
var nano_bot_default = NanoBot;

// nano-bots/obsidian.js
var ObsidianHelpers = class {
  static async insertText(editor, content, region, mode = "replace", prefix = "") {
    editor.replaceSelection(content);
  }
};
var obsidian_default = ObsidianHelpers;

// nano-bots/helpers.js
var NanoBotsHelpers = class {
  static config(plugin) {
    const result = {
      NANO_BOTS_API_ADDRESS: plugin.settings.apiAddress,
      NANO_BOTS_STREAM: plugin.settings.stream,
      NANO_BOTS_END_USER: plugin.settings.endUser
    };
    if (plugin.settings.sendCartridgesPath) {
      result["NANO_BOTS_CARTRIDGES_PATH"] = plugin.settings.cartridgesPath;
    }
    return result;
  }
  static stop() {
    nano_bot_default.stop();
  }
  static async cartridges_as_menu(plugin) {
    const cartridges = await this.cartridges(plugin);
    const items = [];
    for (const cartridge of cartridges) {
      if (cartridge.meta.symbol) {
        items.push({
          title: cartridge.meta.symbol + " " + cartridge.meta.name,
          cartridge
        });
      } else {
        items.push({ title: cartridge.meta.name, cartridge });
      }
    }
    return items;
  }
  static async cartridges(plugin) {
    return nano_bot_default.cartridges(this.config(plugin));
  }
  static cartridge(plugin, cartridge_id) {
    return nano_bot_default.cartridge(this.config(plugin), cartridge_id);
  }
  static async evaluate(plugin, editor, cartridge, state, input, mode, prefix) {
    const params = {
      cartridge,
      state,
      input,
      mode,
      prefix
    };
    const config = this.config(plugin);
    nano_bot_default.perform(config, params, (result) => {
      this.on_output(editor, { config, params }, result);
    });
  }
  static on_output(editor, environment, result) {
    const content = environment.config.NANO_BOTS_STREAM ? result.fragment : result.output;
    const selection = editor.getSelection();
    if (selection !== void 0) {
      obsidian_default.insertText(
        editor,
        content,
        selection.region,
        environment.params.mode,
        environment.params.prefix
      );
    } else {
      obsidian_default.insertText(
        editor,
        content,
        null,
        environment.params.mode,
        environment.params.prefix
      );
    }
  }
};
var helpers_default = NanoBotsHelpers;

// nano-bots/modals/cartridges.js
var import_obsidian3 = require("obsidian");
var CartridgesModal = class extends import_obsidian3.FuzzySuggestModal {
  constructor(app, cartridges, onSubmit) {
    super(app);
    this.cartridges = cartridges;
    this.onSubmit = onSubmit;
  }
  getItems() {
    return this.cartridges;
  }
  getItemText(cartridge) {
    return cartridge.title;
  }
  onChooseItem(item, event) {
    this.onSubmit(item);
  }
};
var cartridges_default = CartridgesModal;

// nano-bots/modals/input.js
var import_obsidian4 = require("obsidian");
var InputModal = class extends import_obsidian4.Modal {
  constructor(app, title, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
    this.title = title;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: this.title });
    new import_obsidian4.Setting(contentEl).setName("Prompt").addText((text) => {
      text.onChange((value) => {
        this.result = value;
      });
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          this.close();
          this.onSubmit(this.result);
        }
      });
    });
    new import_obsidian4.Setting(contentEl).addButton((btn) => btn.setButtonText("Run").setCta().onClick(() => {
      this.close();
      this.onSubmit(this.result);
    }));
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};
var input_default = InputModal;

// nano-bots/dispatcher.js
var NanoBotsDispatcher = class {
  static async run(params, plugin, editor, counter) {
    if (counter > 2) {
      new import_obsidian5.Notice("Nano Bots: Too many input requests: " + counter);
      return;
    }
    if (params.action === "stop") {
      helpers_default.stop();
      return;
    }
    if (!params.cartridge) {
      await this.ask_for_cartridge(params, plugin, editor, counter);
      return;
    }
    if (!editor) {
      new import_obsidian5.Notice("Nano Bots: No open file. Open one to proceed.");
      return;
    }
    const selection = editor.getSelection();
    if (params.action === "evaluate") {
      if (selection === "") {
        return;
      }
      helpers_default.evaluate(
        plugin,
        editor,
        params.cartridge,
        params.state,
        selection,
        params.mode,
        params.prefix
      );
    } else if (params.action === "prompt") {
      if (!params.input) {
        this.ask_for_input(params, plugin, editor, counter);
        return;
      }
      helpers_default.evaluate(
        plugin,
        editor,
        params.cartridge,
        params.state,
        params.input,
        params.mode,
        params.prefix
      );
    } else if (params.action === "apply") {
      if (selection === "") {
        return;
      }
      if (!params.input) {
        this.ask_for_input(params, plugin, editor, counter);
        return;
      }
      const text_input = params.format.replace("[prompt]", params.input).replace("[input]", selection);
      helpers_default.evaluate(
        plugin,
        editor,
        params.cartridge,
        params.state,
        text_input,
        params.mode,
        params.prefix
      );
    }
  }
  static async ask_for_cartridge(params, plugin, editor, counter) {
    const cartridges = await helpers_default.cartridges_as_menu(plugin);
    new cartridges_default(plugin.app, cartridges, (item) => {
      params.cartridge = item.cartridge.system.id;
      params.cartridgeName = item.title;
      NanoBotsDispatcher.run(params, plugin, editor, counter + 1);
    }).open();
  }
  static ask_for_input(params, plugin, editor, counter) {
    new input_default(plugin.app, params.cartridgeName, (input) => {
      params.input = input;
      NanoBotsDispatcher.run(
        params,
        plugin,
        editor,
        counter + 1
      );
    }).open();
  }
};
var dispatcher_default = NanoBotsDispatcher;

// nano-bots/controller.js
var NanoBotsController = class {
  static run(obsidian_params, plugin, editor) {
    const params = Object.assign(
      {
        mode: "replace",
        prefix: "",
        format: "[prompt]: [input]",
        state: "-",
        cartridge: null,
        input: null
      },
      obsidian_params
    );
    dispatcher_default.run(params, plugin, editor, 0);
  }
};
var controller_default = NanoBotsController;

// main.ts
var DEFAULT_SETTINGS = {
  apiAddress: "https://api.nbots.io",
  endUser: "anonymous",
  stream: true,
  sendCartridgesPath: false,
  cartridgesPath: ""
};
var NanoBots = class extends import_obsidian6.Plugin {
  async onload() {
    if (this.app.vault.adapter instanceof import_obsidian6.FileSystemAdapter) {
      const vaultPath = this.app.vault.adapter.getBasePath();
      if (navigator.platform.toLowerCase().includes("win")) {
        DEFAULT_SETTINGS.cartridgesPath = `${vaultPath}\\cartridges:${vaultPath}\\Cartridges`;
      } else {
        DEFAULT_SETTINGS.cartridgesPath = `${vaultPath}/cartridges:${vaultPath}/Cartridges`;
      }
    }
    await this.loadSettings();
    const statusBar = this.addStatusBarItem();
    statusBar.setText("\u{1F916}");
    statusBar.toggleClass("status-hidden", true);
    state_default.instance().setStatusBar(statusBar);
    this.addCommand({
      id: "apply",
      name: "Apply",
      editorCallback: (editor, view) => {
        controller_default.run({ action: "apply" }, this, editor);
      }
    });
    this.addCommand({
      id: "evaluate",
      name: "Evaluate",
      editorCallback: (editor, view) => {
        controller_default.run({ action: "evaluate" }, this, editor);
      }
    });
    this.addCommand({
      id: "prompt",
      name: "Prompt",
      editorCallback: (editor, view) => {
        controller_default.run({ action: "prompt" }, this, editor);
      }
    });
    this.addCommand({
      id: "stop",
      name: "Stop",
      editorCallback: (editor, view) => {
        controller_default.run({ action: "stop" }, this, editor);
      }
    });
    this.addSettingTab(new NanoBotSettingsTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var NanoBotSettingsTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian6.Setting(containerEl).setName("API Address").setDesc("Set the address for the Nano Bots API.").addText((text) => text.setPlaceholder("https://api.nbots.io").setValue(this.plugin.settings.apiAddress).onChange(async (value) => {
      this.plugin.settings.apiAddress = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("End User").setDesc("Your custom user identifier (user-name).").addText((text) => text.setPlaceholder("anonymous").setValue(this.plugin.settings.endUser).onChange(async (value) => {
      this.plugin.settings.endUser = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Stream?").setDesc("Enable or disable streaming.").addToggle((boolean) => boolean.setValue(this.plugin.settings.stream).onChange(async (value) => {
      this.plugin.settings.stream = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Custom Cartridges?").setDesc("Enable or disable custom cartridges.").addToggle((boolean) => boolean.setValue(this.plugin.settings.sendCartridgesPath).onChange(async (value) => {
      this.plugin.settings.sendCartridgesPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Custom Cartridges Path").setDesc("The path where the API should search for custom cartridges.").addText((text) => text.setPlaceholder("anonymous").setValue(this.plugin.settings.cartridgesPath).onChange(async (value) => {
      this.plugin.settings.cartridgesPath = value;
      await this.plugin.saveSettings();
    }));
  }
};
